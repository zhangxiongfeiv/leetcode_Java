#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

> 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
>
> 说明：你不能倾斜容器，且 n 的值至少为 2。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/container-with-most-water
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
>
> **示例：**
>
> ```
> 输入：[1,8,6,2,5,4,8,3,7]
> 输出：49
> ```

### 解题思路

面积为宽 * 高。 宽为数组下标的差值， 高为数组中两个元素较小的元素。假设i,j分别为i，j可盛水的面积， 则得出以下公式

```java
int area = Math.min(nums[i],nums[j]) * (j - i);
```

#### 一，暴力法

暴力法是遍历每一种可能性， 思路很容易理解，代码也非常易懂.

```java
// 暴力法
    public int maxArea1(int[] height) {
        int len = height.length;
        int ans = 0;
		
        for (int i = 0; i < len - 1; i++) {
            for (int j = i + 1; j < len; j++) {

                int area = Math.min(height[i], height[j]) * (j - i);
                ans = Math.max(ans, area);
            }
        }

        return ans;
    }
```

时间复杂度 : O(N ^ 2)

空间复杂度 : O(1)

毫无疑问，执行时间很长， 如图

![https://tva1.sinaimg.cn/large/007S8ZIlly1gds4j1d008j30pi06maaz.jpg]()

#### 二，双指针

接下来，我们使用一种时间复杂度为 O(N) 解决这个问题。

思路：面积和宽度高度有关系，分别从数组的宽度最大到宽度为1的最大面积， 取出计算出的最大值即可。

做法：使用两个指针i,j分别指向数组头部和尾部(j - i为宽)，i，j处较小者为高,计算出面积。 当nums[i] > nums[j] 时, j--, 再次计算面积， 当nums[i] < nums[j] 时，i++;

代码如下

```java
    public int maxArea2(int[] nums) {
        int len = nums.length;
        int max = 0,i = 0, j = len - 1;
        while (i < j){
            int area = Math.min(nums[i],nums[j]) * (j - 1);
            max = Math.max(area,max);

            if (nums[i] > nums[j]){
                j --;
            }else{
                i ++;
            }
        }
        return max;
    }
```

时间复杂度： O（N）

空间复杂度： O（1）

![https://tva1.sinaimg.cn/large/007S8ZIlly1gds5qzcn6qj30p406odgr.jpg]()



#### [26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

#### 解题思路:

双指针法，快慢指针(j ,i)，慢指针(i)指向第一个不重复项的值，快指针逐个往下遍历，当nums[i] != nums[j]时，则把nums[i] = nums[j], 且i++,j++；

当nums[i] == nums[j]时，只需要j ++。

#### 代码如下：

```java
    	public static int removeDuplicates(int[] nums) {
            int i = 0;
        		for (int j = 1; j < nums.length; j++) {
            	if (nums[i] != nums[j]){
                i ++;
                nums[i] = nums[j];
            	}
        	}
       		 return i + 1;
      }
```

时间复杂度: O(N)

空间复杂度: O(1)



#### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
>  
>
> 示例 1:
>
> 给定 nums = [3,2,2,3], val = 3,
>
> 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
>
> 你不需要考虑数组中超出新长度后面的元素。
> 示例 2:
>
> 给定 nums = [0,1,2,2,3,0,4,2], val = 2,
>
> 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
>
> 注意这五个元素可为任意顺序。
>
> 你不需要考虑数组中超出新长度后面的元素。
>
>
> 说明:
>
> 为什么返回数值是整数，但输出的答案是数组呢?
>
> 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
>
> 你可以想象内部操作如下:
>
> // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
> int len = removeElement(nums, val);
>
> // 在函数里修改输入数组对于调用者是可见的。
> // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
> for (int i = 0; i < len; i++) {
>     print(nums[i]);
> }
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/remove-element
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 解题思路：

定义变量记录新数组长度，初始值为数组长度，从后往前，遍历元素， 当遍历的元素 和 所需移除的元素相等时，记录新数组长度的变量--, 并且用当前元素后的元素往前覆盖。 

代码如下：

```java
   public static int removeElement1(int[] nums, int val) {
        int len = nums.length;
        for (int i = nums.length - 1; i >= 0; i--) {
            if (nums[i] == val){
                len --;
                for (int j = i; j < nums.length - 1; j++) {
                    nums[j] = nums[j + 1];
                }
            }
        }
        return len;
    }

```

最坏时间复杂度 : O(N ^ 2)  可能存在过多重复移动的情况

空间复杂度 : O(1)



##### 方法二：双指针法

###### 思路

i指针指向不新数组的末尾，j遍历原数组，遍历过程中 元素与val一致时，只j++，不做其他事，当不一样时，新数组赋值下标i为 nums[j].  

```java
    public int removeElements1(int[] nums, int val){
        int i = 0;
        for (int j = 1; j < nums.length; j++) {
            if (nums[j] != val){
                nums[i] = nums[j];
                i ++;
            }
        }
        return i;
    }
```

时间复杂度 ：O(N ^ 2)

空间复杂度 ：O(1)



#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 你可以假设数组中无重复元素。
>
> 示例 1:
>
> 输入: [1,3,5,6], 5
> 输出: 2
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/search-insert-position
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 解题思路：

二分查找(Binary Search) ,也叫折半查找，是一种高效的查找方法。 但是二分查找要求线性表必须采取顺序存储结构，而且表中元素按关键字顺序排列。最坏数据复杂度O(logN)

代码如下

```java
    public int searchInsert(int[] nums, int target) {
        if(nums == null || nums.length == 0) return -1;
        if(target > nums[nums.length - 1]) return nums.length;
				
        int l = 0, r = nums.length - 1;
        while (l < r){
            int mid = (l + r) >> 1;
            if (target == nums[mid]){
                return mid;
            }else if (target > nums[mid]){
                l = mid + 1;
            }else {
                r = mid;
            }
        }
        return l;
    }
```



#### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

> 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
>
>  
>
> 说明:
>
> 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
> 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
>
>
> 示例:
>
> 输入:
> nums1 = [1,2,3,0,0,0], m = 3
> nums2 = [2,5,6],       n = 3
>
> 输出: [1,2,2,3,5,6]
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/merge-sorted-array
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 思路：

nums1 为结果数组且有足够的空间，把nums2的结果逐步插入nums1合适的位置即可，从后往前（从大到小）依次把nums2的元素合并到nums1中即可。

#### 代码如下：

```java
    public static void merge(int[] nums1, int m, int[] nums2, int n) {
        int index = m + n - 1;
        int idx1 = m - 1;
        int idx2 = n - 1;

        while (idx1 >=0 || idx2 >= 0){

            if (idx2 < 0){
                break;
            }

            if (idx1 < 0){
                while (idx2 >= 0){
                    nums1[index --] = nums2[idx2 --];
                }
                continue;
            }

            if (nums1[idx1] > nums2[idx2]){
                nums1[index --] = nums1[idx1 --];
            }else {
                nums1[index--] = nums2[idx2--];
            }
        }
    }
```

时间复杂度： O(N ^ 2)

空间复杂度： O(1)