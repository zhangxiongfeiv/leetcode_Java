## 栈

栈是一种特殊的线性表,只能在一端操作

往栈中添加元素的操作，一般叫做push，入栈

从栈中移除元素的操作，一般叫做pop，出栈（只能移除栈顶元素，也叫做弹出栈顶元素）

后进先出的原则，Last In First Out, LIFO

### 练习题

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
>
> 有效字符串需满足：
>
> 左括号必须用相同类型的右括号闭合。
> 左括号必须以正确的顺序闭合。
> 注意空字符串可被认为是有效字符串。
>
> 示例 1:
>
> 输入: "()"
> 输出: true
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/valid-parentheses
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 题解：

这道题使用栈数据结构。

1，左括号时，入栈，

2，右括号时，如果栈顶是与其对应的左括号， 则出栈。如果不对应，则返回false。

3，最终返回结果是栈是否为空

### 代码如下：

```java
private static HashMap<Character,Character> map = new HashMap<>();
    static {
        map.put('(',')');
        map.put('[',']');
        map.put('{','}');
    }
    public boolean isValid(String s) {
        Stack stack = new Stack();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (map.containsKey(c)){
                stack.push(c);
            }else {
                if (stack.isEmpty() || map.get(stack.peek()) != c) return false;
                stack.pop();
            }
        }
        return stack.isEmpty();
    }
```



#### [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

> 根据逆波兰表示法，求表达式的值。
>
> 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
>
> 说明：
>
> 整数除法只保留整数部分。
> 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
> 示例 1：
>
> 输入: ["2", "1", "+", "3", "*"]
> 输出: 9
> 解释: ((2 + 1) * 3) = 9
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 题解：

思路： 遍历数组，当时数字时入栈，当是运算符是弹出栈顶两个元素，运算，并将结果入栈。 遍历完毕，栈顶元素即是结果。

代码如下：

```java
public int evalRPN(String[] tokens){

        final HashSet<String> symbols = new HashSet<String>(){{
            add("+");
            add("-");
            add("*");
            add("/");
        }};

        Stack<String> stack = new Stack<>();
        for (int i = 0; i < tokens.length; i++) {
            String s = tokens[i];
            if (symbols.contains(s)){
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());

                int res = 0;
                if (s.equals("+")){
                    res = num2 + num1;
                }else if (s.equals("-")){
                    res = num2 - num1;
                }else if (s.equals("*")){
                    res = num2 * num1;
                }else {
                    res = num2 / num1;
                }

                stack.push(String.valueOf(res));
            }else{
                stack.push(s);
            }
        }

        return Integer.parseInt(stack.peek());
    }
```

时间复杂度： O（N）

空间复杂度：O（N）

##### 另一种写法：

```java
public int evalRPN(String[] tokens){
        
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < tokens.length; i++) {
            String s = tokens[i];
    
                if (s.equals("+")){
                    stack.push(stack.pop() + stack.pop());
                }else if (s.equals("-")){
                    Integer tmp = stack.pop();
                    stack.push(stack.pop() - tmp);
                }else if (s.equals("*")){
                    stack.push(stack.pop() * stack.pop());
                }else if(s.equals("/")){
                    Integer tmp = stack.pop();
                    stack.push(stack.pop() / tmp);
                }else{
                    stack.push(Integer.parseInt(s));
                }
        }
        
        return stack.peek();
    }
```



#### [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

> 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
>
> push(x) —— 将元素 x 推入栈中。
> pop() —— 删除栈顶的元素。
> top() —— 获取栈顶元素。
> getMin() —— 检索栈中的最小元素。
> 示例:
>
> MinStack minStack = new MinStack();
> minStack.push(-2);
> minStack.push(0);
> minStack.push(-3);
> minStack.getMin();   --> 返回 -3.
> minStack.pop();
> minStack.top();      --> 返回 0.
> minStack.getMin();   --> 返回 -2.
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/min-stack
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 题解：

借助辅助栈，以空间换时间，辅助栈是单调栈，存放的元素依次递减。获取最小元素时，直接取辅助栈栈顶元素，故其获取最小值时间复杂度O(1).

#### 代码如下：

```java
public class _155_最小栈 {

    // 数据栈
    private Stack<Integer> stack;
    // 辅助栈
    private Stack<Integer> minStack;
    public _155_最小栈() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }

    public void push(int x) {
        // 数据栈直接入栈
        stack.push(x);
        // 当辅助栈栈顶 >= x时，直接入栈。 否则再次入栈栈顶元素
        if (minStack.isEmpty() || minStack.peek() >= x){
            minStack.push(x);
        }else {
            minStack.push(minStack.peek());
        }
    }

    public void pop() {
        // 两个栈都 pop
        stack.pop();
        minStack.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

时间复杂度：O(1) push pop getMin top 时间复杂度都是O（1）

空间复杂度：O(N) 利用了额外的辅助栈



#### [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

> 使用队列实现栈的下列操作：
>
> push(x) -- 元素 x 入栈
> pop() -- 移除栈顶元素
> top() -- 获取栈顶元素
> empty() -- 返回栈是否为空
> 注意:
>
> 你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。
> 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
> 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/implement-stack-using-queues
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 题解：

用队列实现栈，队列先进先出，栈后进先出，用两个队列实现栈，q1是存储正常元素， q2在pop 或者 top时用，pop或者top时先把q1的元素出队并加入q2中直到q1.size == 1时，q1.size == 1时，记录q1.pop或者peek为tmp，然后把q2 与 q1交换，最后返回tmp。

##### 代码如下：

```java
private Queue<Integer> q1;
    private Queue<Integer> q2;
    /** Initialize your data structure here. */
    public MyStack() {
        q1 = new LinkedList<>();
        q2 = new LinkedList<>();
    }

    /** Push element x onto stack. */
    public void push(int x) {
        q1.add(x);
    }

    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        q2.clear();
        while (!q1.isEmpty()){
            if (q1.size() != 1){
                q2.add(q1.remove());
            }else {
                Queue tmp = q1;
                q1 = q2;
                q2 = tmp;

                return q2.remove();
            }
        }
        return -1;
    }


    /** Get the top element. */
    public int top() {
        q2.clear();
        while (!q1.isEmpty()){
            if (q1.size() != 1){
                q2.add(q1.remove());
            }else {
                q2.add(q1.peek());
                Queue tmp = q1;
                q1 = q2;
                q2 = tmp;

                return q2.peek();
            }
        }
        return -1;
    }

    /** Returns whether the stack is empty. */
    public boolean empty() {
        return q1.size() == 0;
    }
```



#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

> 使用栈实现队列的下列操作：
>
> push(x) -- 将一个元素放入队列的尾部。
> pop() -- 从队列首部移除元素。
> peek() -- 返回队列首部的元素。
> empty() -- 返回队列是否为空。
> 示例:
>
> MyQueue queue = new MyQueue();
>
> queue.push(1);
> queue.push(2);  
> queue.peek();  // 返回 1
> queue.pop();   // 返回 1
> queue.empty(); // 返回 false
> 说明:
>
> 你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
> 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
> 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/implement-queue-using-stacks
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 题解：

栈后进先出，队列先进先出，用栈实现队列

1，需要两个栈inStack 和 outStack,

2，入队时inStack 压栈。 

3，出队时如果outStack不为空，则outStack 出栈， 如果outStack为空， 把inStack中的元素，依次pop并压入outStack中，inStack元素全部压入outStack中后，返回outStack pop。

4，peek时，与出队列类似，pop换做peek即可。 

5，isEmpty 判断inStack 和 outStack都为空才是空

#### 代码如下：

```java
public class _232_用栈实现队列{

	private Stack<Integer> inStack;
	private Stack<Integer> outStack;

	public _232_用栈实现队列(){
		inStack = new Stack<>();
		outStack = new Stack<>();
	}

	public void push(int x){
		inStack.push(x);
	}

	public int pop(){
		if (!outStack.isEmpty()) {
			return outStack.pop();
		}else {
			while(!inStack.isEmpty()){
				outStack.push(inStack.pop());
			}

			return outStack.pop();
		}
	}

	public int peek(){
		if (!outStack.isEmpty()) {
			return outStack.peek();
		}else{
			while(!inStack.isEmpty()){
				outStack.push(inStack.pop());
			}
			return outStack.peek();
		}
	}

	public boolean empty(){
		return inStack.isEmpty() && outStack.isEmpty();
	}
}
```



#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

