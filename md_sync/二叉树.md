### 二叉树

#### 二叉树的遍历

有两种遍历树的策略：

- 深度优先搜索(DFS)

  在这个策略中，我们采用**深度**作为优先级，以便从根开始一直到达某个确定的叶子，然后再返回根到达下一个分支。

  深度优先搜索，又可以根据根节点，左子节点和右子节点的相对顺序被分为 **前序遍历** ，**中序遍历**，**后序遍历**。

- 宽度优先搜索(BFS)

  我们按照一层一层访问整棵树，高层次的节点将比低层次的节点先访问到。



如下图中，按照1 2 3 4 5比较不同的策略。

![image-20200506155730459](https://tva1.sinaimg.cn/large/007S8ZIlly1geisbs9gpmj30um0dujvl.jpg)



#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

> 给定一个二叉树，返回它的 前序 遍历。
>
>  示例:
>
> 输入: [1,null,2,3]  
>    1
>     \
>      2
>     /
>    3 
>
> 输出: [1,2,3]
> 进阶: 递归算法很简单，你可以通过迭代算法完成吗？
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

###### 思路一：

使用递归，先遍历头节点，再左，再右。代码如下：

```java
    ArrayList <Integer>list = new ArrayList<>();
    // 递归
    public List<Integer> preorderTraversalRecursive (TreeNode root) {

        if (root == null) return list;
        list.add(root.val);
        preorderTraversalRecursive(root.left);
        preorderTraversalRecursive(root.right);

        return list;
    }
```



###### 思路二：

迭代，需要使用额外的栈空间存储结构。

```java
    public List<Integer> preorderTransversalRecursive1(TreeNode root){
        ArrayList <Integer>list = new ArrayList<>();
        if (root == null) return list;

        Stack <TreeNode>stack = new Stack();
        stack.push(root);

        while (!stack.isEmpty()){

            TreeNode node = stack.pop();
            list.add(node.val);

            if (node.right != null){
                stack.push(node.right);
            }

            if (node.left != null){
                stack.push(node.left);
            }
        }
        return list;
    }
```

时间复杂度： O(N)

空间复杂度： O(N)

![屏幕快照 2020-05-06 下午4.34.52](https://tva1.sinaimg.cn/large/007S8ZIlly1geitrbaih9j311y0k4108.jpg)



#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

> 给定一个二叉树，返回它的中序 遍历。
>
> 示例:
>
> 输入: [1,null,2,3]
>    1
>     \
>      2
>     /
>    3
>
> 输出: [1,3,2]
> 进阶: 递归算法很简单，你可以通过迭代算法完成吗？
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

###### 思路一：

递归，代码如下：

```java
    ArrayList<Integer> list = new ArrayList<>();
    public List<Integer> inorderTraversalRevursive(TreeNode root){
        if (root == null) return list;

        inorderTraversalRevursive(root.left);
        list.add(root.val);
        inorderTraversalRevursive(root.right);

        return list;
    }
```

###### 思路二：

迭代:

![in](https://tva1.sinaimg.cn/large/007S8ZIlly1geitsz9ge1j31120jwn4d.jpg)

代码如下：

```java
    public List<Integer> inorderTraversal(TreeNode root){
        ArrayList<Integer> list = new ArrayList<>();
        if (root == null) return list;

        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while (!stack.isEmpty() || node != null){

            while (node != null){
                stack.push(node);
                node = node.left;
            }

            node = stack.pop();
            list.add(node.val);
            node = node.right;
        }

        return list;
    }
```



#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

> 给定一个二叉树，返回它的 后序 遍历。
>
> 示例:
>
> 输入: [1,null,2,3]  
>    1
>     \
>      2
>     /
>    3 
>
> 输出: [3,2,1]
> 进阶: 递归算法很简单，你可以通过迭代算法完成吗？
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

###### 思路一：

递归，代码如下：

```java
// 递归
    ArrayList <Integer> list = new ArrayList<>();
    public List<Integer> postorderTraversalRecuisive(TreeNode root) {

        if (root == null) return list;
        postorderTraversalRecuisive(root.left);
        postorderTraversalRecuisive(root.right);

        list.add(root.val);

        return list;
    }
```



###### 思路二：

迭代：

![屏幕快照 2020-05-06 下午4.35.19](https://tva1.sinaimg.cn/large/007S8ZIlly1geiu02hbf5j311y0kqagz.jpg)

代码如下：

```java
// 非递归
    public List<Integer> postorderTraversal(TreeNode root) {

        ArrayList <Integer> list = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        if (root == null) return list;

        stack.push(root);
        TreeNode pre = null;
        while (!stack.isEmpty()){
            TreeNode node = stack.peek();
            if ((node.left == null && node.right == null)|| (pre != null && (pre == node.left || pre == node.right))) {
                // 叶子节点 或者 上一个访问的节点是此节点的子节点时 出栈
                list.add(node.val);
                pre = node;
                stack.pop();
            }else{
                // 右子节点不为空
                if (node.right != null) stack.push(node.right);
                // 左子节点不为空
                if (node.left != null) stack.push(node.left);
            }
        }

        return list;
    }
```



#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

> 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
>
>  
>
> 示例：
> 二叉树：[3,9,20,null,null,15,7],
>
>     3
>    / \
>   9  20
>     /  \
>    15   7
> 返回其层次遍历结果：
>
> [
>   [3],
>   [9,20],
>   [15,7]
> ]
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

实现思路，使用队列：

1. 将根节点入队
2. 循环执行以下操作，直到队列为空
   - 将对头节点A出对，进行访问
   - 将A的左子节点入队
   - 将A的右子节点入队

![level](https://tva1.sinaimg.cn/large/007S8ZIlly1geiudzhnwkj31200k0doc.jpg)



代码如下：

```java
public List<List<Integer>> levelOrder(TreeNode root){
        ArrayList list = new ArrayList();
        
        if (root == null) return list;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        
        TreeNode node = root;
        while (!queue.isEmpty()){
            ArrayList a = new ArrayList();
            int count = queue.size();
            while (count > 0){
                node = queue.remove();
                
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
                
                a.add(node.val);
                count --;
            }
            
            list.add(a);
        }
        
        return list;
    }
```



#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

##### 题解：

###### 思路一：

使用递归， node节点的高度等于其 max(node.left, node.right) + 1 左右孩子的高度中的较大者 + 1. 代码如下：

```java

    public int maxDepth(TreeNode root){
        if (root == null) return 0;
        
        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;
    }
```



###### 思路二：

迭代， 类似层序遍历，当一层遍历完时，height ++ . 直到遍历完所有节点

代码如下：

```java
public int maxDepth(TreeNode root) {
        if (root == null) return 0;

        Queue <TreeNode> queue = new LinkedList<>();
        queue.add(root);
        TreeNode node = root;

        int height = 0;
        while (!queue.isEmpty()){
            int size = queue.size();
            while (size > 0){

                node = queue.remove();
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);

                size --;
            }

            height ++;
        }

        return height;
    }
```



#### [662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

> 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。
>
> 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。
>
> 示例 1:
>
> 输入: 
>
>            1
>          /   \
>         3     2
>        / \     \  
>       5   3     9 
>
> 输出: 4
> 解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。
> 示例 2:
>
> 输入: 
>
>           1
>          /  
>         3    
>        / \       
>       5   3     
>
> 输出: 2
> 解释: 最大值出现在树的第 3 层，宽度为 2 (5,3)。
> 示例 3:
>
> 输入: 
>
>           1
>          / \
>         3   2 
>        /        
>       5      
>
> 输出: 2
> 解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。
> 示例 4:
>
> 输入: 
>
>           1
>          / \
>         3   2
>        /     \  
>       5       9 
>      /         \
>     6           7
> 输出: 8
> 解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。
> 注意: 答案在32位有符号整数的表示范围内。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/maximum-width-of-binary-tree
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

层序遍历，计算每一层的宽度，各层中宽度的最大值就是最终结果。 每一层的宽度我们需要每层元素的下标。下标存入链表中，如果有左子树，其左子树的下标为index * 2. 右子树的下标为index * 2 + 1.   

代码如下：

```java
public static int widthOfBinaryTree(TreeNode root) {

        if (root == null) return 0;

        Queue<TreeNode> queue = new LinkedList<>();
        LinkedList<Integer> list = new LinkedList<>();

        queue.add(root);
        list.add(1);
        int maxWidth = 0;

        while (!queue.isEmpty()){
            int size = queue.size();
            maxWidth = Math.max(size,maxWidth);

            while (size > 0){
                TreeNode node = queue.remove();
                Integer curIdx = list.removeFirst();

                if (node.left != null){
                    queue.add(node.left);
                    list.add(curIdx * 2);
                }
                if (node.right != null) {
                    queue.add(node.right);
                    list.add(curIdx * 2 + 1);
                }

                size --;
            }

            if (list.size() >= 2){
                maxWidth = Math.max(maxWidth, list.getLast() - list.getFirst() + 1);
            }
        }

        return maxWidth;
    }
```



#### [589. N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

##### 题解：

###### 思路一：

递归

代码如下：

```java
ArrayList list = new ArrayList();
public List<Integer> preorder(Node root) {
    if (root == null) return list;
    
    Node node = root;
    list.add(node.val);

    for (int i = 0; i < root.children.size(); i++){
        
        preorder(node.children.get(i));
    }
    
    return list;
}
```

###### 思路二：

迭代 , 跟二叉树前序遍历相同.

```java
public List<Integer> preorder(Node root) {
    if (root == null) return list;

    Stack<Node> stack = new Stack<>();
    stack.push(root);

    while (!stack.isEmpty()){

        Node node = stack.pop();
        list.add(node.val);

        for (int i = node.children.size() - 1; i >= 0; i--) {
            stack.push(node.children.get(i));
        }
    }

    return list;
}
```



#### [590. N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)

