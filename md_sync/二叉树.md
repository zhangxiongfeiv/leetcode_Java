### 二叉树

#### 二叉树的遍历

有两种遍历树的策略：

- 深度优先搜索(DFS)

  在这个策略中，我们采用**深度**作为优先级，以便从根开始一直到达某个确定的叶子，然后再返回根到达下一个分支。

  深度优先搜索，又可以根据根节点，左子节点和右子节点的相对顺序被分为 **前序遍历** ，**中序遍历**，**后序遍历**。

- 宽度优先搜索(BFS)

  我们按照一层一层访问整棵树，高层次的节点将比低层次的节点先访问到。



如下图中，按照1 2 3 4 5比较不同的策略。

![image-20200506155730459](https://tva1.sinaimg.cn/large/007S8ZIlly1geisbs9gpmj30um0dujvl.jpg)



#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

> 给定一个二叉树，返回它的 前序 遍历。
>
>  示例:
>
> 输入: [1,null,2,3]  
>    1
>     \
>      2
>     /
>    3 
>
> 输出: [1,2,3]
> 进阶: 递归算法很简单，你可以通过迭代算法完成吗？
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

思路一：

使用递归，先遍历头节点，再左，再右。代码如下：

```java
    ArrayList <Integer>list = new ArrayList<>();
    // 递归
    public List<Integer> preorderTraversalRecursive (TreeNode root) {

        if (root == null) return list;
        list.add(root.val);
        preorderTraversalRecursive(root.left);
        preorderTraversalRecursive(root.right);

        return list;
    }
```



思路二：

迭代，需要使用额外的栈空间存储结构。

```java
    public List<Integer> preorderTransversalRecursive1(TreeNode root){
        ArrayList <Integer>list = new ArrayList<>();
        if (root == null) return list;

        Stack <TreeNode>stack = new Stack();
        stack.push(root);

        while (!stack.isEmpty()){

            TreeNode node = stack.pop();
            list.add(node.val);

            if (node.right != null){
                stack.push(node.right);
            }

            if (node.left != null){
                stack.push(node.left);
            }
        }
        return list;
    }
```

时间复杂度： O(N)

空间复杂度： O(N)

![屏幕快照 2020-05-06 下午4.34.52](https://tva1.sinaimg.cn/large/007S8ZIlly1geitrbaih9j311y0k4108.jpg)



#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

> 给定一个二叉树，返回它的中序 遍历。
>
> 示例:
>
> 输入: [1,null,2,3]
>    1
>     \
>      2
>     /
>    3
>
> 输出: [1,3,2]
> 进阶: 递归算法很简单，你可以通过迭代算法完成吗？
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

思路一：

递归，代码如下：

```java
    ArrayList<Integer> list = new ArrayList<>();
    public List<Integer> inorderTraversalRevursive(TreeNode root){
        if (root == null) return list;

        inorderTraversalRevursive(root.left);
        list.add(root.val);
        inorderTraversalRevursive(root.right);

        return list;
    }
```

迭代:

![in](https://tva1.sinaimg.cn/large/007S8ZIlly1geitsz9ge1j31120jwn4d.jpg)

代码如下：

```java
    public List<Integer> inorderTraversal(TreeNode root){
        ArrayList<Integer> list = new ArrayList<>();
        if (root == null) return list;

        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while (!stack.isEmpty() || node != null){

            while (node != null){
                stack.push(node);
                node = node.left;
            }

            node = stack.pop();
            list.add(node.val);
            node = node.right;
        }

        return list;
    }
```



#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

> 给定一个二叉树，返回它的 后序 遍历。
>
> 示例:
>
> 输入: [1,null,2,3]  
>    1
>     \
>      2
>     /
>    3 
>
> 输出: [3,2,1]
> 进阶: 递归算法很简单，你可以通过迭代算法完成吗？
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

思路一：

递归，代码如下：

```java
// 递归
    ArrayList <Integer> list = new ArrayList<>();
    public List<Integer> postorderTraversalRecuisive(TreeNode root) {

        if (root == null) return list;
        postorderTraversalRecuisive(root.left);
        postorderTraversalRecuisive(root.right);

        list.add(root.val);

        return list;
    }
```



迭代：

![屏幕快照 2020-05-06 下午4.35.19](https://tva1.sinaimg.cn/large/007S8ZIlly1geiu02hbf5j311y0kqagz.jpg)

代码如下：

```java
// 非递归
    public List<Integer> postorderTraversal(TreeNode root) {

        ArrayList <Integer> list = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        if (root == null) return list;

        stack.push(root);
        TreeNode pre = null;
        while (!stack.isEmpty()){
            TreeNode node = stack.peek();
            if ((node.left == null && node.right == null)|| (pre != null && (pre == node.left || pre == node.right))) {
                // 叶子节点 或者 上一个访问的节点是此节点的子节点时 出栈
                list.add(node.val);
                pre = node;
                stack.pop();
            }else{
                // 右子节点不为空
                if (node.right != null) stack.push(node.right);
                // 左子节点不为空
                if (node.left != null) stack.push(node.left);
            }
        }

        return list;
    }
```



#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

> 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
>
>  
>
> 示例：
> 二叉树：[3,9,20,null,null,15,7],
>
>     3
>    / \
>   9  20
>     /  \
>    15   7
> 返回其层次遍历结果：
>
> [
>   [3],
>   [9,20],
>   [15,7]
> ]
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

实现思路，使用队列：

1. 将根节点入队
2. 循环执行以下操作，直到队列为空
   - 将对头节点A出对，进行访问
   - 将A的左子节点入队
   - 将A的右子节点入队

![level](https://tva1.sinaimg.cn/large/007S8ZIlly1geiudzhnwkj31200k0doc.jpg)



代码如下：

```java
public List<List<Integer>> levelOrder(TreeNode root){
        ArrayList list = new ArrayList();
        
        if (root == null) return list;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        
        TreeNode node = root;
        while (!queue.isEmpty()){
            ArrayList a = new ArrayList();
            int count = queue.size();
            while (count > 0){
                node = queue.remove();
                
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
                
                a.add(node.val);
                count --;
            }
            
            list.add(a);
        }
        
        return list;
    }
```

