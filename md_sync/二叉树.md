### 二叉树

#### 二叉树的遍历

有两种遍历树的策略：

- 深度优先搜索(DFS)

  在这个策略中，我们采用**深度**作为优先级，以便从根开始一直到达某个确定的叶子，然后再返回根到达下一个分支。

  深度优先搜索，又可以根据根节点，左子节点和右子节点的相对顺序被分为 **前序遍历** ，**中序遍历**，**后序遍历**。

- 宽度优先搜索(BFS)

  我们按照一层一层访问整棵树，高层次的节点将比低层次的节点先访问到。



如下图中，按照1 2 3 4 5比较不同的策略。

![image-20200506155730459](https://tva1.sinaimg.cn/large/007S8ZIlly1geisbs9gpmj30um0dujvl.jpg)



#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

> 给定一个二叉树，返回它的 前序 遍历。
>
>  示例:
>
> 输入: [1,null,2,3]  
>    1
>     \
>      2
>     /
>    3 
>
> 输出: [1,2,3]
> 进阶: 递归算法很简单，你可以通过迭代算法完成吗？
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

###### 思路一：

使用递归，先遍历头节点，再左，再右。代码如下：

```java
    ArrayList <Integer>list = new ArrayList<>();
    // 递归
    public List<Integer> preorderTraversalRecursive (TreeNode root) {

        if (root == null) return list;
        list.add(root.val);
        preorderTraversalRecursive(root.left);
        preorderTraversalRecursive(root.right);

        return list;
    }
```



###### 思路二：

迭代，需要使用额外的栈空间存储结构。

```java
    public List<Integer> preorderTransversalRecursive1(TreeNode root){
        ArrayList <Integer>list = new ArrayList<>();
        if (root == null) return list;

        Stack <TreeNode>stack = new Stack();
        stack.push(root);

        while (!stack.isEmpty()){

            TreeNode node = stack.pop();
            list.add(node.val);

            if (node.right != null){
                stack.push(node.right);
            }

            if (node.left != null){
                stack.push(node.left);
            }
        }
        return list;
    }
```

时间复杂度： O(N)

空间复杂度： O(N)

![屏幕快照 2020-05-06 下午4.34.52](https://tva1.sinaimg.cn/large/007S8ZIlly1geitrbaih9j311y0k4108.jpg)



#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

> 给定一个二叉树，返回它的中序 遍历。
>
> 示例:
>
> 输入: [1,null,2,3]
>    1
>     \
>      2
>     /
>    3
>
> 输出: [1,3,2]
> 进阶: 递归算法很简单，你可以通过迭代算法完成吗？
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

###### 思路一：

递归，代码如下：

```java
    ArrayList<Integer> list = new ArrayList<>();
    public List<Integer> inorderTraversalRevursive(TreeNode root){
        if (root == null) return list;

        inorderTraversalRevursive(root.left);
        list.add(root.val);
        inorderTraversalRevursive(root.right);

        return list;
    }
```

###### 思路二：

迭代:

![in](https://tva1.sinaimg.cn/large/007S8ZIlly1geitsz9ge1j31120jwn4d.jpg)

代码如下：

```java
    public List<Integer> inorderTraversal(TreeNode root){
        ArrayList<Integer> list = new ArrayList<>();
        if (root == null) return list;

        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while (!stack.isEmpty() || node != null){

            while (node != null){
                stack.push(node);
                node = node.left;
            }

            node = stack.pop();
            list.add(node.val);
            node = node.right;
        }

        return list;
    }
```



#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

> 给定一个二叉树，返回它的 后序 遍历。
>
> 示例:
>
> 输入: [1,null,2,3]  
>    1
>     \
>      2
>     /
>    3 
>
> 输出: [3,2,1]
> 进阶: 递归算法很简单，你可以通过迭代算法完成吗？
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

###### 思路一：

递归，代码如下：

```java
// 递归
    ArrayList <Integer> list = new ArrayList<>();
    public List<Integer> postorderTraversalRecuisive(TreeNode root) {

        if (root == null) return list;
        postorderTraversalRecuisive(root.left);
        postorderTraversalRecuisive(root.right);

        list.add(root.val);

        return list;
    }
```



###### 思路二：

迭代：

![屏幕快照 2020-05-06 下午4.35.19](https://tva1.sinaimg.cn/large/007S8ZIlly1geiu02hbf5j311y0kqagz.jpg)

代码如下：

```java
// 非递归
    public List<Integer> postorderTraversal(TreeNode root) {

        ArrayList <Integer> list = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        if (root == null) return list;

        stack.push(root);
        TreeNode pre = null;
        while (!stack.isEmpty()){
            TreeNode node = stack.peek();
            if ((node.left == null && node.right == null)|| (pre != null && (pre == node.left || pre == node.right))) {
                // 叶子节点 或者 上一个访问的节点是此节点的子节点时 出栈
                list.add(node.val);
                pre = node;
                stack.pop();
            }else{
                // 右子节点不为空
                if (node.right != null) stack.push(node.right);
                // 左子节点不为空
                if (node.left != null) stack.push(node.left);
            }
        }

        return list;
    }
```



#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

> 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
>
>  
>
> 示例：
> 二叉树：[3,9,20,null,null,15,7],
>
>     3
>    / \
>   9  20
>     /  \
>    15   7
> 返回其层次遍历结果：
>
> [
>   [3],
>   [9,20],
>   [15,7]
> ]
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

实现思路，使用队列：

1. 将根节点入队
2. 循环执行以下操作，直到队列为空
   - 将对头节点A出对，进行访问
   - 将A的左子节点入队
   - 将A的右子节点入队

![level](https://tva1.sinaimg.cn/large/007S8ZIlly1geiudzhnwkj31200k0doc.jpg)



代码如下：

```java
public List<List<Integer>> levelOrder(TreeNode root){
        ArrayList list = new ArrayList();
        
        if (root == null) return list;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        
        TreeNode node = root;
        while (!queue.isEmpty()){
            ArrayList a = new ArrayList();
            int count = queue.size();
            while (count > 0){
                node = queue.remove();
                
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
                
                a.add(node.val);
                count --;
            }
            
            list.add(a);
        }
        
        return list;
    }
```



#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

##### 题解：

###### 思路一：

使用递归， node节点的高度等于其 max(node.left, node.right) + 1 左右孩子的高度中的较大者 + 1. 代码如下：

```java

    public int maxDepth(TreeNode root){
        if (root == null) return 0;
        
        return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;
    }
```



###### 思路二：

迭代， 类似层序遍历，当一层遍历完时，height ++ . 直到遍历完所有节点

代码如下：

```java
public int maxDepth(TreeNode root) {
        if (root == null) return 0;

        Queue <TreeNode> queue = new LinkedList<>();
        queue.add(root);
        TreeNode node = root;

        int height = 0;
        while (!queue.isEmpty()){
            int size = queue.size();
            while (size > 0){

                node = queue.remove();
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);

                size --;
            }

            height ++;
        }

        return height;
    }
```



#### [662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

> 给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。
>
> 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。
>
> 示例 1:
>
> 输入: 
>
>            1
>          /   \
>         3     2
>        / \     \  
>       5   3     9 
>
> 输出: 4
> 解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。
> 示例 2:
>
> 输入: 
>
>           1
>          /  
>         3    
>        / \       
>       5   3     
>
> 输出: 2
> 解释: 最大值出现在树的第 3 层，宽度为 2 (5,3)。
> 示例 3:
>
> 输入: 
>
>           1
>          / \
>         3   2 
>        /        
>       5      
>
> 输出: 2
> 解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。
> 示例 4:
>
> 输入: 
>
>           1
>          / \
>         3   2
>        /     \  
>       5       9 
>      /         \
>     6           7
> 输出: 8
> 解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。
> 注意: 答案在32位有符号整数的表示范围内。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/maximum-width-of-binary-tree
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

层序遍历，计算每一层的宽度，各层中宽度的最大值就是最终结果。 每一层的宽度我们需要每层元素的下标。下标存入链表中，如果有左子树，其左子树的下标为index * 2. 右子树的下标为index * 2 + 1.   

代码如下：

```java
public static int widthOfBinaryTree(TreeNode root) {

        if (root == null) return 0;

        Queue<TreeNode> queue = new LinkedList<>();
        LinkedList<Integer> list = new LinkedList<>();

        queue.add(root);
        list.add(1);
        int maxWidth = 0;

        while (!queue.isEmpty()){
            int size = queue.size();
            maxWidth = Math.max(size,maxWidth);

            while (size > 0){
                TreeNode node = queue.remove();
                Integer curIdx = list.removeFirst();

                if (node.left != null){
                    queue.add(node.left);
                    list.add(curIdx * 2);
                }
                if (node.right != null) {
                    queue.add(node.right);
                    list.add(curIdx * 2 + 1);
                }

                size --;
            }

            if (list.size() >= 2){
                maxWidth = Math.max(maxWidth, list.getLast() - list.getFirst() + 1);
            }
        }

        return maxWidth;
    }
```



#### [589. N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

##### 题解：

###### 思路一：

递归

代码如下：

```java
ArrayList list = new ArrayList();
public List<Integer> preorder(Node root) {
    if (root == null) return list;
    
    Node node = root;
    list.add(node.val);

    for (int i = 0; i < root.children.size(); i++){
        
        preorder(node.children.get(i));
    }
    
    return list;
}
```

###### 思路二：

迭代 , 跟二叉树前序遍历相同.

```java
public List<Integer> preorder(Node root) {
    if (root == null) return list;

    Stack<Node> stack = new Stack<>();
    stack.push(root);

    while (!stack.isEmpty()){

        Node node = stack.pop();
        list.add(node.val);

        for (int i = node.children.size() - 1; i >= 0; i--) {
            stack.push(node.children.get(i));
        }
    }

    return list;
}
```



#### [590. N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)

> 给定一个 N 叉树，返回其节点值的后序遍历。
>
> 例如，给定一个 3叉树 :
>
>  
>
> 返回其后序遍历: [5,6,3,2,4,1].
>
>  
>
> 说明: 递归法很简单，你可以使用迭代法完成此题吗?
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

###### 思路一：

递归，先遍历头节点，然后循环依次递归遍历头节点的子节点。代码如下：

```java
    ArrayList list = new ArrayList();
    public List<Integer> postorder(Node root) {

        if (root == null) return list;

        Node node = root;
        for (int i = 0; i < node.children.size(); i++) {
            Node n = node.children.get(i);
            postorder(n);
        }
        list.add(root.val);

        return list;
    }
```

思路二：

迭代， 跟二叉树的后序遍历迭代法，逻辑一致。

- 将root入栈
- 循环执行以下操纵，直到栈为空
  - 如果栈顶元素是叶子节点，或者上一次访问的节点是当前节点的子节点时，则栈顶元素出栈访问
  - 否则，将栈顶元素的children从大到小依次入栈。

代码如下：

```java
// 迭代
    public List<Integer> postorder(Node root){
        ArrayList list = new ArrayList();
        if (root == null) return list;

        Stack<Node> stack = new Stack<>();
        stack.push(root);
        Node pre = null;

        while (!stack.isEmpty()){
            Node node = stack.peek();

            if (node.children.size() == 0 || node.children.contains(pre)){
                // 如果是叶子节点 或者 上一次访问的节点是此节点的子节点时  出栈访问
                list.add(node.val);

                pre = node;
                stack.pop();
            }else {
                for (int i = node.children.size() - 1; i >= 0; i--) {
                    stack.push(node.children.get(i));
                }
            }
        }

        return list;
    }
```





#### [559. N叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

##### 题解：

###### 思路一：

递归，非常容易想的思路，父节点的深度，等于其子节点中最大深度再加一。 代码如下：

```java
    public int maxDepth(Node root) {
        if (root == null) return 0;
        
        int max = 1;
        for (int i = 0; i < root.children.size(); i++) {
            max = Math.max(max,maxDepth(root.children.get(i)) + 1);
        }

        return max;
    }
```

###### 思路二：

迭代，利用树的层序遍历，遍历完一层时，高度+1, 直到遍历完整棵树。代码如下：

```java
// 迭代 层序遍历
    public int maxDepth(Node root) {
        if (root == null) return 0;

        Queue<Node> queue = new LinkedList<>();
        queue.add(root);
        Node node = root;

        int height = 0;
        while (!queue.isEmpty()){
            int size = queue.size();

            while (size > 0){
                node = queue.remove();

                for (int i = 0; i < node.children.size(); i++) {
                    queue.add(node.children.get(i));
                }

                size --;
            }

            height ++;
        }

        return height;
    }
```



#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

##### 题解：

思路一：

迭代, 可以发现展开的顺序其实就是二叉树前序遍历。

1. 将左子树插入到右子树
2. 将原来的右子树插入到左子树最右边节点
3. 考虑新的右子树的根节点，重复上边的过程

```java
    1
   / \
  2   5
 / \   \
3   4   6

//将 1 的左子树插入到右子树的地方
    1
     \
      2         5
     / \         \
    3   4         6        
//将原来的右子树接到左子树的最右边节点
    1
     \
      2          
     / \          
    3   4  
         \
          5
           \
            6
            
 //将 2 的左子树插入到右子树的地方
    1
     \
      2          
       \          
        3       4  
                 \
                  5
                   \
                    6   
        
 //将原来的右子树接到左子树的最右边节点
    1
     \
      2          
       \          
        3      
         \
          4  
           \
            5
             \
              6         
  

```

代码如下：

```java
// 第一步：将左子树 插入到右子树上
    // 第二步：将之前的右子树 插入到之前左子树的最右边节点
    // 第三部：考虑新的右子树的根节点，重复上边的过程
    public void flattern(TreeNode root){

        while (root != null){
            if (root.left == null){
                // 如果没有左子树，直接处理其右子树
                root = root.right;
                continue;
            }

            // 将原来右子树保存一份
            TreeNode tmp = root.right;
            
            // 把左子树 插入 到右子树的位置
            root.right = root.left;
            
            // 清空原来左子树
            root.left = null;

            // 找到原来 左子树的最右边节点
            TreeNode pre = root.right;
            while (pre.right != null){
                pre = pre.right;
            }

            // 原来的右子树 插入到 原来左子树的最右边
            pre.right = tmp;

            root = root.right;
        }
    }
```

###### 思路二： 

递归：  其实跟上述做法思路类似

1. 分别将左子树 和 右子树变为链表
2. 把左子树插入到右子树的位置，
3. 将原来右子树插入到原来左子树的最右边

```java
   // 递归
    // 第一步 左子树变为链表
    // 第二步 右子树变为链表
    // 第三步 原来的左子树 插入到右子树的位置
    // 第四步 清空原来的左子树
    // 第五步 把原来的右子树 插入到原来左子树的最右边
    public void flatten(TreeNode root){
        if (root == null) return;

        // 左子树变为链表
        flatten(root.left);
        // 右子树变为链表
        flatten(root.right);

        // 保存原来的右子树
        TreeNode tmp = root.right;
        // 左子树插入到右子树位置
        root.right = root.left;
        // 清空左子树
        root.left = null;

        // 找到左子树的最右边
        TreeNode pre = root.right;
        while (pre.right != null){
            pre = pre.right;
        }
        
        // 原来的右子树 插入到左子树的最右边
        pre.right = tmp;
    }

```



#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

> 根据一棵树的中序遍历与后序遍历构造二叉树。
>
> 注意:
> 你可以假设树中没有重复的元素。
>
> 例如，给出
>
> 中序遍历 inorder = [9,3,15,20,7]
> 后序遍历 postorder = [9,15,7,20,3]
> 返回如下的二叉树：
>
>   	3
>
>    /	 \
>   9  	20
>  /    \
>
> 15   7
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



##### 题解：

**如何根据两种遍历序列构造数:  中序，和前序 / 后序等等**

- 通常从前序遍历或者后序遍历开始，根据不同遍历方法的规律，选择合适的节点构造树
  - 比如，前序遍历的第一个节点就是根节点，然后是它的左子节点，右子节点。
  - 后序遍历的最后一个节点是根节点，然后是它的右子节点，左子节点。
- 从先序 / 后序序列中找到根节点，根据根节点将中序序列分为左子树，右子树。 从中序序列中获得的信息是： 如果当前子树为空 (返回 None), 否则继续构造子树。

###### 算法步骤：

1. 创建map用来存放中序遍历的值和下标。
2. rootIdx 用来存放后序遍历数组中，创建root节点的下标
3. 将后序遍历数组全局化
4. 后序遍历的最后一个元素是根节点，先拿到根节点，在上述map中查找在中序遍历中的index, 因为中序遍历顺序为 **左 中 右**。 所以左子树为[0, index - 1], 右子树为[index + 1, end]。
5. 递归构造根节点的 右子树 和 左子树。 这里要注意，一定是先构造右子树。 因为后序遍历的顺序为  **左 右 中**  ，所以出去最后一个元素后，最后一个元素为右子树的根节点
6. 依次构建，直到没有元素。

代码如下：

```java
// map中存放中序遍历的节点和索引值
    HashMap<Integer,Integer> map = new HashMap<>();
    int[] postorder = null;
    int rootIdx = 0;

    public TreeNode buildTree(int[] inorder, int[] postorder) {

        if (inorder.length == 0 || postorder.length == 0 || inorder.length != postorder.length) return null;
        if (inorder.length == 1) return new TreeNode(inorder[0]);

        this.postorder = postorder;
        this.rootIdx = postorder.length - 1;
        // 将中序遍历的节点和索引值存入数组
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i],i);
        }

        return buildTreeHelper(0,inorder.length - 1);
    }


    private TreeNode buildTreeHelper(int is, int ie){

        // 左边索引 > 右边索引 -> 没有元素
        if (is > ie) return null;

        // 后序遍历最后一位是根节点，或者根节点的索引
        int idx = map.get(postorder[rootIdx]);

        // 根节点
        TreeNode node = new TreeNode(postorder[rootIdx]);

        rootIdx --;
        // 右子树 ：  【idx + 1, inorder.length - 1】
        node.right = buildTreeHelper(idx + 1, ie);
        // 左子树 ：  【0 ， idx-1】
        node.left = buildTreeHelper(is,idx - 1);

        return node;
    }
```

##### 复杂度分析：

时间复杂度： O(N), 递归N次，其中N为节点个数

空间复杂度：O(N), 使用递归，需要额外的栈空间，由于栈的深度为N，故空间复杂度为 O(N). 



#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

> 根据一棵树的前序遍历与中序遍历构造二叉树。
>
> 注意:
> 你可以假设树中没有重复的元素。
>
> 例如，给出
>
> 前序遍历 preorder = [3,9,20,15,7]
> 中序遍历 inorder = [9,3,15,20,7]
> 返回如下的二叉树：
>
>     3
>    / \
>   9  20
>     /  \
>    15   7
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

此题跟上一道题，根据后序遍历和中序遍历构造二叉树思路基本一致。 

- 存储中序遍历的节点 和 下标对应的map
- 前序遍历首元素为二叉树的根节点，找到根节点，在map中找到下标
- 中序遍历遍历顺序为 **根节点 左 右** , 所以根节点的左子树为[0, idx - 1]. 右子树为[idx + 1,end].
- 分别构建左右子树

代码如下：

```java
HashMap<Integer,Integer> map = new HashMap<>(); // 用于存放中序遍历的 元素 -> 下标对应的字典
int rootIdx = 0;                                // 存放前序遍历的数组中，root的下标
int[] preorder = null;                          // 全局化 前序遍历数组

private TreeNode buildTreeHelper(int startIdx, int endIdx){
    if (startIdx > endIdx) return null;

    TreeNode root = new TreeNode(preorder[rootIdx]);
    int idx = map.get(preorder[rootIdx]);

    rootIdx ++;

    // 左子树
    root.left = buildTreeHelper(startIdx,idx - 1);

    // 右子树
    root.right = buildTreeHelper(idx + 1, endIdx);

    return root;
}

public TreeNode buildTree(int[] preorder, int[] inorder) {

    if (inorder.length == 0 || preorder.length == 0 || inorder.length != preorder.length) return null;
    if (inorder.length == 1) return new TreeNode(inorder[0]);

    for (int i = 0; i < inorder.length; i++) {
        map.put(inorder[i],i);
    }
    this.preorder = preorder;

    return buildTreeHelper(0,preorder.length - 1);
}
```

##### 复杂度分析：

时间复杂度： O(N), 递归N次，其中N为节点个数

空间复杂度：O(N), 使用递归，需要额外的栈空间，由于栈的深度为N，故空间复杂度为 O(N). 