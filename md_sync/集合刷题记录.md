## 集合（Set）

#### 集合的定义：

由一个或者多个确定的元素所构成的整体。

#### 特点：

1，不存在重复元素

2，一般用于去重（比如一本书中统计词汇，统计访问网站的ip）

#### 实现：

可使用动态数组，链表，二叉搜索树等实现集合。

ListSet(使用链表)  TreeSet(使用红黑树) HashSet(哈希表)

#### 复杂度分析：

TreeSet： 添加，删除，查找时间复杂度都是 O(logN)

ListSet ： 添加，删除，查找时间复杂度都是O(logN)

HashSet:  添加，删除，查找时间复杂度都是O(logN)

#### TreeMap局限性：

元素必须具备可比较性，如果没有可比较性， 无法使用TreeMap。因为二叉搜索树中的元素必须具备可比较性。



### 练习题

#### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

> 给定两个数组，编写一个函数来计算它们的交集。
>
> 示例 1:
>
> 输入: nums1 = [1,2,2,1], nums2 = [2,2]
> 输出: [2]
> 示例 2:
>
> 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出: [9,4]
> 说明:
>
> 输出结果中的每个元素一定是唯一的。
> 我们可以不考虑输出结果的顺序。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 题解：

把第一个数组依次加入firSet去重，第二个数组也依次加入secSet中去重复，遍历secSet如果firSet中包含，则加入结果数组中。 

代码如下:

```java
public int[] intersection(int[] nums1, int[] nums2){

        HashSet set = new HashSet();
        for (int i = 0; i < nums1.length; i++) {
            set.add(nums1[i]);
        }

        HashSet resSet = new HashSet();
        for (int i = 0; i < nums2.length; i++) {
            if (set.contains(nums2[i]))
                resSet.add(nums2[i]);
        }

        int[] res = new int[resSet.size()];
        Iterator iterator = resSet.iterator();
        int k = 0;
        while (iterator.hasNext()){
            res[k] = (int)iterator.next();
            k++;
        }
        return res;
    }
```

时间复杂度 ：O（m + n）

空间复杂度 ：最坏的情况O(m + n)



#### [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

> 编写一个算法来判断一个数 n 是不是快乐数。
>
> 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。
>
> 如果 n 是快乐数就返回 True ；不是，则返回 False 。
>
>  
>
> 示例：
>
> 输入：19
> 输出：true
> 解释：
> 12 + 92 = 82
> 82 + 22 = 68
> 62 + 82 = 100
> 12 + 02 + 02 = 1
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/happy-number
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 题解：

思路一： 使用HashSet记录之前循环过的值， 当包含时，判断其是不是1.

```java
    public static boolean s(int n){
        Set<Integer> set = new HashSet<>();
        while (n != 1 && !set.contains(n)){
            set.add(n);
            n = nextNum(n);
        }
        return n == 1;
    }

	  public static int nextNum(int n){
        int res = 0;
        while (n > 0){
            int bit = n % 10;
            res += Math.pow(bit,2);
            n = n / 10;
        }
        return res;
    }
```

时间复杂度：O(logN)

空间复杂度：O(logN)



思路二：利用快慢指针思想，快指针每次走两步，慢指针每次走一步，当两者相同时即为一个循环周期。此时，判断是不是因为1引起的循环，是的话就是快乐数，否则就不是快乐数。

```java
public static boolean s(int n){
 		int slow = n;
  	int fast = nextNum(n);
  
  	while(slow != fast){
      slow = nextNum(slow);
      fast = nextNum(nextNum(fast));
    }
    return slow == 1;
}

	  public static int nextNum(int n){
        int res = 0;
        while (n > 0){
            int bit = n % 10;
            res += Math.pow(bit,2);
            n = n / 10;
        }
        return res;
    }
```

