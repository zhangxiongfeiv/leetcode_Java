

### 思考？

在 n 个动态的整数中搜索某个整数？ (查看其是否存在)

- 假设用动态数组存放元素，从第0个位置开始遍历搜索，平均时间复杂度 O(N)
- 如果维护一个有序的动态数组，使用二分搜索，最坏时间复杂度 O(log N)
  - 但是添加，删除的平均时间复杂度是 O(N)
- 针对这个需求， 有没有更好的方案？
  - 使用二叉搜索树，添加/删除/搜索的最坏时间复杂度均可优化至 O(log N)



### 定义：

二叉搜索树是二叉树的一种，是应用非常广泛的一种二叉树，英文简称 BST ，又被称为：二叉查找树，二叉排序树

- 任意节点的值都 **大于** 其左子树的节点的值
- 任意节点的值都 **小于** 其右子树节点的值
- 它的左右子树也是一棵二叉搜索树



二叉搜索树可以大大提高搜索数据的效率

二叉搜索树存储的元素必须具备可比较性

- 比如int , double类型
- 如果是自定义类型，需要指定比较方式
- 不允许为 null



### 练习题：

#### [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

> 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
>
> 一般来说，删除节点可分为两个步骤：
>
> 首先找到需要删除的节点；
> 如果找到了，删除它。
> 说明： 要求算法时间复杂度为 O(h)，h 为树的高度。
>
> 示例:
>
> root = [5,3,6,2,4,null,7]
> key = 3
>
>     5
>    / \
>   3   6
>  / \   \
> 2   4   7
>
> 给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
>
> 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
>
>     5
>    / \
>   4   6
>  /     \
> 2       7
>
> 另一个正确答案是 [5,2,6,null,4,null,7]。
>
>     5
>    / \
>   2   6
>    \   \
>     4   7
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/delete-node-in-a-bst
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

##### 题解：

二叉树的特征：

- 二叉搜索树的中序遍历的序列是递增的序列，因为中序遍历的遍历次序依次是 left -> Node -> right;

```java
// 二叉树的中序遍历
public LinkedList<Integer> inorder(TreeNode root, LinkedList<Integer> arr){
		if(root == null) return arr;
		
		inorder(root.left, arr);
		arr.add(root.val);
		inorder(root.right, arr);
		
		return arr;
}
```

![image-20200509140727307](https://tva1.sinaimg.cn/large/007S8ZIlly1gem6097ysvj30e608cq3p.jpg)

- 后继节点
  - 是右子树上最左边的节点
  - 是中序遍历的后一个节点

```java
    // 后继节点
    // 是右子树上最左边的节点
    // 是其中序遍历的后一个节点
    private TreeNode successor(TreeNode root){
        root = root.right;
        while (root.left != null) root = root.left;
        return root;
    }
```

- 前驱节点
  - 是左子树上最右边的节点
  - 是中序遍历的前一个节点

```java
    // 前驱节点
    // 是左子树上最右边的节点
    // 是其中序遍历的前一个节点
    private TreeNode predecessor(TreeNode root){
        root = root.left;
        while (root.right != null) root = root.right;
        return root;
    }
```

![image-20200509141023674](/Users/liuxiaoyong/Library/Application Support/typora-user-images/image-20200509141023674.png)



- 方法： 递归

  - 这里有三种情况，删除叶子节点，直接删除即可。不会影响二叉搜索树的性质。

  ![image-20200509141235458](/Users/liuxiaoyong/Library/Application Support/typora-user-images/image-20200509141235458.png)

  

  - 删除的节点有右子节点， 则找其后继节点， 后继节点的值覆盖当前节点的值， 递归删除后继节点

  ![image-20200509141259250](/Users/liuxiaoyong/Library/Application Support/typora-user-images/image-20200509141259250.png)

  - 删除的节点有左子节点，则找其前驱节点，前驱节点的值覆盖当前节点的值，递归删除前驱节点

  ![image-20200509141318066](/Users/liuxiaoyong/Library/Application Support/typora-user-images/image-20200509141318066.png)





代码如下：

```java
public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null;

        if (root.val > key){
            // 在左子树
            root.left = deleteNode(root.left,key);
        }else if (root.val < key){
            // 在右子树
            root.right = deleteNode(root.right,key);
        }else {
            // 相等 -> 找到了
            if (root.left == null && root.right == null) {
                // 如果是叶子节点
                root  = null;
            } else if (root.right != null) {
                // 如果有右子节点
                // 找后继，用后继节点把 当前节点替换，然后再删除后继节点
                root.val = successor(root).val;
                root.right = deleteNode(root.right,root.val);
            } else {
                // 有左子节点
                // 找前驱，用前驱节点把 当前节点替换，然后再删除前驱节点
                root.val = predecessor(root).val;
                root.left = deleteNode(root.left,root.val);
            }
        }

        return root;
    }

    // 二叉搜索树的中序遍历
    // 中序遍历是递增排序的序列，中序遍历的遍历次序是 left -> Node -> right

    // 后继节点
    // 是右子树上最左边的节点
    // 是其中序遍历的后一个节点
    private TreeNode successor(TreeNode root){
        root = root.right;
        while (root.left != null) root = root.left;
        return root;
    }

    // 前驱节点
    // 是左子树上最右边的节点
    // 是其中序遍历的前一个节点
    private TreeNode predecessor(TreeNode root){
        root = root.left;
        while (root.right != null) root = root.right;
        return root;
    }
```

复杂度分析：

时间复杂度: O(log N). 

空间复杂度：O(H), 递归时堆栈使用的空间，H是树的高度。





#### [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

##### 题解： 

###### 思路一：

迭代：题目非常简单，普通的二叉搜索树查找。 代码如下：

```java
    // 二叉搜索树性质， 左子树的值都比根节点小， 右子树的值都比根节点大。
    // 当节点值小于 当前节点值时， 查找其左子树。
    // 当节点值大于 当前节点值时， 查找其右子树
    // 相等时 返回

    // 找到最后，不存在则返回 null
    // 迭代
    public TreeNode searchBST1(TreeNode root, int val) {

        while (root != null){
            if (root.val == val) return root;

            if (root.val > val){
                root = root.left;
            }else {
                root = root.right;
            }
        }
        return null;
    }
```

时间复杂度： O(H) ，其中H为树高，平均时间复杂度 O(log N), 最坏时间复杂度: O(N).

空间复杂度: O(1)。



###### 思路二： 

递归 ， 代码如下：

```java
    // 递归
    public TreeNode searchBST(TreeNode root, int val) {

        if (root == null) return root;

        if (root.val == val) return root;
        if (root.val > val) return searchBST(root.left,val);

        return searchBST(root.right,val);
    }
```

时间复杂度： O(H) ，其中H为树高，平均时间复杂度 O(log N), 最坏时间复杂度: O(N).

空间复杂度: O(H), 平均情况下深度为 O(log⁡N)，最坏情况下深度为 O(N)O(*N*)





#### [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

##### 题解：

二叉搜索树的插入操作非常简单，当val > root.val时，插入root的左子树, 当val < root.val时，插入root的右子树。

###### 思路一：

递归，代码如下：

```java
    // 递归
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) return new TreeNode(val);

        if (val > root.val) {
            root.right = insertIntoBST(root.right, val);
        }else {
            root.left = insertIntoBST(root.left,val);
        }
        return root;
    }
```

###### 思路二： 

迭代，代码如下：

```java
    // 迭代
    public TreeNode insertIntoBST1(TreeNode root, int val) {
        if (root == null) return new TreeNode(val);

        TreeNode node = root;
        while (node != null){
            if (val > node.val){
                if (node.right == null){
                    node.right = new TreeNode(val);
                    return root;
                }else {
                    node = node.right;
                }
            }else {
                if (node.left == null){
                    node.left = new TreeNode(val);
                    return root;
                }else {
                    node = node.left;
                }
            }
        }
        return new TreeNode(val);
    }
```



#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

##### 题解：

- 迭代 和 递归两种方法思路一样， 都是利用二叉树的中序遍历
-  二叉搜索树的中序遍历结果，是严格升序的， 所以我们中序遍历二叉树
- 记录前一个遍历的节点，当前节点的值 比 前一个节点小或者相等时， 不满足BST，return false。 否则继续遍历
- 遍历完毕，没有出现不满足的情况， 则为BST

###### 思路一：

迭代：代码如下：

```java
    // 迭代
    public boolean isValidBST1(TreeNode root) {

        long prev = Long.MIN_VALUE;
        Stack <TreeNode>stack = new Stack<>();
        TreeNode node = root;

        while (!stack.isEmpty() || node != null){

            while (node != null){
                stack.push(node);
                node = node.left;
            }

            node = stack.pop();
            if (node.val <= prev) return false;
            prev = node.val;
            node = node.right;
        }
        return true;
    }
```

###### 思路二：

递归: 代码如下：

```java

    // 递归
    long prev = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root){

        if (root == null) return true;

        // 访问左子树
        if (!isValidBST(root.left)) return false;

        // 访问当前节点，如果当前节点的值比前一个节点的值小， 则不满足BST, return false。 否则继续遍历
        if (prev >= root.val) return false;

        // 记录前一个节点的值
        prev = root.val;

        return isValidBST(root.right);
    }
```



#### [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

> 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

##### 题解：

- 二叉搜索树中序遍历的结果，是升序数组
- 中序遍历二叉树，每一步记录与上一步的差值，取最小值即为最终结果



###### 思路一：

迭代

```java
public int getMinimumDifference1(TreeNode root){

        // 中序遍历前一个元素
        TreeNode prev = null;
        // 保存最小差值
        int minDiff = Integer.MAX_VALUE;

        Stack<TreeNode> stack = new Stack<>();

        while (!stack.isEmpty() || root != null){
            while (root != null){
                stack.push(root);
                root = root.left;
            }

            root = stack.pop();
            if (prev == null)
                minDiff = Integer.MAX_VALUE;
            else
                minDiff = Math.min(root.val - prev.val, minDiff);

            prev = root;

            root = root.right;
        }

        return minDiff;
    }
```



###### 思路二：

递归

```java
   // 递归
    TreeNode prev = null;
    int minDiff = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root){
        if (root == null) return Integer.MAX_VALUE;

        // 找到左子树的最小差值
        getMinimumDifference(root.left);

        // 计算当前节点的最小差值
        int val = root.val;
        if (prev == null)
            minDiff = Integer.MAX_VALUE;
        else
            minDiff = Math.min(root.val - prev.val,minDiff);

        prev = root;

        // 找到右子树的最小差值
        getMinimumDifference(root.right);
        
        return minDiff;
    }
```



#### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

> 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。
>
> 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
>
> 示例:
>
> 给定有序数组: [-10,-3,0,5,9],
>
> 一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：
>
>        0
>       / \
>      -3  9
>      /   /
>     -10  5
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



##### 题解：

将有序数组转换为二叉搜索树的结果为什么 不唯一？

对于偶数个数的数组，要么选择中间节点位置左边的元素作为根节点，要么选择中间节点的右边元素作为根节点，不同的方案会创建不同的二叉树。 

- 中序遍历不能唯一确定一棵二叉搜索树
- 前序和后序遍历不能确定唯一一棵二叉搜索树
- 前序/后序 和 中序可以唯一确定一棵二叉树。

因此，有序数组 -> BST 有多种答案。



以下题解， 当偶数时，选择中间节点右边的元素作为根节点

- 找到中间元素，根据中间元素创建根节点
- 根据中间元素把有序数组分为两部分，左边为根节点的左子树，右边为根节点的右子树。
- 递归 分别得到左子树和右子树。

代码如下：

```java
    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length == 0) return null;

        return sortedArray(nums,0,nums.length);
    }

    // 左闭右开
    public TreeNode sortedArray(int[] nums, int begain, int end){

        if (begain >= end) return null;

        int mid = (begain + end) >> 1;

        TreeNode root = new TreeNode(nums[mid]);
        root.left = sortedArray(nums,begain,mid);
        root.right = sortedArray(nums,mid + 1, end);

        return root;
    }
```

时间复杂度: O(N), 每个元素都要访问一次

空间复杂度: O(N), 二叉搜索树空间 O(N), 递归栈深度 O(log N).



#### [938. 二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)

##### 题解：

二叉树中序遍历， 递加在 [L , R]  范围的元素即可。

###### 思路一：

递归 代码如下：

```java
		int sum = 0;
    public int rangeSumBST(TreeNode root, int L, int R){
        if (root == null) return 0;

        rangeSumBST(root.left, L ,R);
        if (root.val >= L && root.val <= R){
            sum += root.val;
        }
        rangeSumBST(root.right,L,R);

        return sum;
    }
```

###### 思路二：

迭代 代码如下：

```java
 // 迭代
    public int rangeSumBST1(TreeNode root, int L, int R){
        if (root == null) return 0;

        // 保存最终结果
        int sum = 0;

        Stack<TreeNode> stack = new Stack<>();
        while (!stack.isEmpty() || root != null){
            while (root != null){
                stack.push(root);
                root = root.left;
            }

            root = stack.pop();
            if (root.val >= L && root.val <= R){
                sum += root.val;
            }

            root = root.right;
        }

        return sum;
    }
```

