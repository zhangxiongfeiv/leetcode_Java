## Fabrique - 优化问题记录



### 1,从服务端获取数据,尽量减少需要在客户端进行的处理.

- 物流列表,一个节点可能对应好几个地点 (比如运输中: 北京 - 天津 - 河北 等等), 原本服务端返回的N条数据中都有 节点信息, 客户端需要 使用 **双指针算法**,把返回的数据进行 **O(N)** 次的计算,再进行渲染
  - 经跟服务端沟通, 服务端进行返回数据优化,返回的数据可以直接用,减少了客户端的能耗 和 速度 



### 2,更优的数据结构和算法

- 列表去重复, 做feed流,又一个无法避免的问题, 就是列表去重
  - 比如用户在拉去第二页数据时,这时又有一条新信息插入, 这时用户拿到的第二页数据的第一条,就与第一页数据的最后一条重复了.
  - 客户端肯定希望服务端做到去重, 但是与服务端沟通无果,只能客户端去重复
  - 客户端的做法 : 记录一个 内容ID 的数组, 拿到新的数据后,挨个判断是否在 ID数组中, 如果包含在 ID数组中, 则证明重复了,丢弃此条数据, 否则将 此条内容的id加入 ID数组
    - 又一个明显的问题,当数据量大时,客户端就废了
      - 比如,一页20条数据,用户拉取了 500页数据, 此时 ID 数组中就存放着 10000条数据
      - 当我们再次拉下一页的20条时, 就需要进行 20 * 10000次的运算才能做到去重操作
      - 客户端的耗时是非常大的, 如何优化呢?
  - 优化一?
    - 使用 Set 代替 动态数组
    - 如上边的例子, 当我们判断 第 501页的数据是否重复时,只要 20(pageSize) 次的计算就课知道数据是否重复了.
    - 时间复杂度上提高了很多
  - 但是还有问题
    - O(N) 空间复杂度的 Set, 本身占据内存空间就特别大, 我们知道 Set 底层就是数组, 通过 **哈希运算** 出下标, 当哈希碰撞时还会转换为链表 和 红黑树. 其本身比数组占据的空间就大(因为元素不连续)
      - 这也是一种 **以空间换时间的思想** 体现
    - 所以当 用户拉取列表页数多时,非常消耗设备内存.
  - 优化二?
    - **滚动数组**.
    - 我们允许一定的误差, 比如第1页的数据 和 第 4 页的数据重复.
    - 数组中固定保存 **40条(两页)** 的数据,当拉取第三页时, 第三页的ID存入**滚动数组**后,我们把第一页的数据删除.
      - 再拉取第四页时
      - 第四页的数据与第二三页的数据 的 ID比较去除重复.
      - 仍然把 第四页的ID放入 滚动数组,移除第二页的 ID
    - 这样我们不管用户拉取多少页, **滚动数组中元素数量恒 <= 40**,  而每次判断时计算的次数恒 <= 800(40 * 20)
  - Fabrique采取的优化二的方案
    - 我们允许一定误差的存在, 比如,跨度好几页的数据如果出现重复我们可以接受
    - 我们不希望,出现用户滑动列表因为去重出现 **卡顿(算法耗时)**, 或者 **大量占用内存**的情况
    - 所以我们使用 优化二种 **滚动数组** 的方法,避免绝大多数情况的数据重复, 也不会引起**卡顿, 内存消耗大** 等问题.
    - 这也是我们在两者之间找到的一种平衡.
  - 总结 : 
    - Feed流重复问题最好由服务端解决, 因为我们服务端没有方案,只好客户端去处理.
    - 处理时, 要在所用的数据结构和算法, 以及用户体验之间找到一个平衡点.



### 设计模式-工厂模式的使用

#### 需求: 

- Fabrique项目中, 有很多的**信息流**, 比如 我的Fabs, 商品详情晒单, 订单列表晒单, 消息中心晒单, 设计师标记晒单等等.
- 其中这些信息流中大部分UI 和 逻辑重复, 不同之处也有,比如页面 Title不一样, 请求的接口名以及接口的传参不一样,以及埋点上报的参数不一样等等



#### 初步实现 : 

- 有大部分的逻辑重叠, 很容易想到使用统一类, 逻辑不同的地方加上各种 **Switch Case** 判断即可. 
- 所以,  我写了 **FBFabsListVC** 类, 因为信息流类别众多, 造成 **FBFabsListVC** 类中有大量恶心的 **Switch Case**, 而且如果我们新增一类信息流, 又会导致 此类 代码逻辑增多, 导致代码混乱,难以维护.



#### 优化一:

- 很明显, 我们把所有逻辑,包括公共逻辑以及私有逻辑全部写在一类中, 是不明智的行为. 
  - 会导致 此类 代码逻辑复杂, 代码量巨大,难以维护.
- 所以想到, 每类信息流都创建各自的类, 且统一都继承  **FBFabsListVC**
  - 公共的逻辑,我们依然放在 **FBFabsListVC** 中,避免代码重复
  - 私有的逻辑,我们交给 **子类** 自己去实现
- 优化过后, 代码逻辑清晰了, 新增一类信息流时, 不必要去修改 **FBFabsListVC** 而造成其逻辑膨胀.
  - 只需要增加子类,单独处理特殊逻辑,并继承**FBFabsListVC**即可.



#### 优化二:

- 经过优化一, 我们的代码逻辑看起来比之前清晰了很多.
  - 但是如果想隐藏子类实现细节, 外部调用时, 根据传入的值的类型,判断生成哪种类型的子类. 
  - 调用者不需要知道子类, 只需要传入响应的参数得到对应的类即可.
- 接下来,就是这次使用的主角, **简单工厂模式**.
- 创建了 **FabsListFactory** 工厂类
  - 工厂中定义了枚举值
  - 根据枚举值生产对应的 子类对象
- 外部使用信息流时,  使用工厂,传入对应的枚举值, 获取对应的子类即可
- 用父类指针**FBFabsListVC**指向 子类对象
- 这样外部调用不需要知道具体是哪种子类, 只要使用工厂生产即可.



#### ObjC抽象类:

- 上述类别中, **FBFabsListVC** 是基类, 但是其本身不能够被直接实力化使用.
- 因为私有逻辑并没有在 **FBFabsListVC** 中实现.
- 在Java 中, 这种类称为 **抽象类**,并且有 **abstract** 关键字修饰.
- 但是在 ObjC 中并没有 **abstract** 关键字.
- 所以我们需要,模拟一下抽象类, 具体做法 [模拟ojbc中抽象类的使用][https://zhxiongfei.github.io/post/模拟ojbc中抽象类的使用/]





### 3, 运行时监控卡顿, FPS等开发

- **卡顿** 等现象,  总是难以避免, 虽然 **Instruments** 工具足够优秀, 可以**检测并定位** 卡顿.
- 同样也有**限制**,只能获取到我们连接到电脑并运行的, 对于普通用户手机上发生的 **偶现的卡顿**, 我们仍然一无所知.
- 所以, 我们希望开发一个监控卡顿的工具. 核心功能为 : 
  - **监控卡顿**
  - **主线程堆栈**
  - **符号解析**
  - **发送到服务端** 
- 使用到的技术以及难点 : 
  - 监控卡顿:  我们主要通过**监控主线程 RunLoop** 来实现
  - 获取主线程堆栈信息 以及符号解析 : 需要用到非常底层的 API, 主要参考了 **[BSBacktraceLogger](https://github.com/bestswifter/BSBacktraceLogger)**
  - 发送服务端 : 通过发送到服务端堆栈信息,来分析卡顿发生位置, 继而优化
- 开发的详细过程,以及碰到的难点信息,请参考 **[Fabrique监控并优化卡顿]()**

