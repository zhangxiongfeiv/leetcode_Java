## Fabrique - 优化能耗问题记录



1,从服务端获取数据,尽量减少需要在客户端进行的处理.

- 物流列表,一个节点可能对应好几个地点 (比如运输中: 北京 - 天津 - 河北 等等), 原本服务端返回的N条数据中都有 节点信息, 客户端需要 使用 **双指针算法**,把返回的数据进行 O(N) 次的计算,再进行渲染
  - 经跟服务端沟通, 服务端进行返回数据优化,返回的数据可以直接用,减少了客户端的能耗 和 速度 



2,更优的数据结构和算法

- 列表去重复, 做feed流,又一个无法避免的问题, 就是列表去重
  - 比如用户在拉去第二页数据时,这时又有一条新信息插入, 这时用户拿到的第二页数据的第一条,就与第一页数据的最后一条重复了.
  - 客户端肯定希望服务端做到去重, 但是与服务端沟通无果,只能客户端去重复
  - 客户端的做法 : 记录一个 内容ID 的数组, 拿到新的数据后,挨个判断是否在 ID数组中, 如果包含在 ID数组中, 则证明重复了,丢弃此条数据, 否则将 此条内容的id加入 ID数组
    - 又一个明显的问题,当数据量大时,客户端就废了
      - 比如,一页20条数据,用户拉取了 500页数据, 此时 ID 数组中就存放着 10000条数据
      - 当我们再次拉下一页的20条时, 就需要进行 20 * 10000次的运算才能做到去重操作
      - 客户端的耗时是非常大的, 如何优化呢?
  - 优化一?
    - 使用 Set 代替 动态数组
    - 如上边的例子, 当我们判断 第 501页的数据是否重复时,只要 20(pageSize) 次的计算就课知道数据是否重复了.
    - 时间复杂度上提高了很多
  - 但是还有问题
    - O(N) 空间复杂度的 Set, 本身占据内存空间就特别大, 我们知道 Set 底层就是数组, 通过 **哈希运算** 出下标, 当哈希碰撞时还会转换为链表 和 红黑树. 其本身比数组占据的空间就大(因为元素不连续)
      - 这也是一种 **以空间换时间的思想** 体现
    - 所以当 用户拉取列表页数多时,非常消耗设备内存.
  - 优化二?
    - **滚动数组**.
    - 我们允许一定的误差, 比如第1页的数据 和 第 4 页的数据重复.
    - 数组中固定保存 **40条(两页)** 的数据,当拉取第三页时, 第三页的ID存入**滚动数组**后,我们把第一页的数据删除.
      - 再拉取第四页时
      - 第四页的数据与第二三页的数据 的 ID比较去除重复.
      - 仍然把 第四页的ID放入 滚动数组,移除第二页的 ID
    - 这样我们不管用户拉取多少页, **滚动数组中元素数量恒 <= 40**,  而每次判断时计算的次数恒 <= 800(40 * 20)
  - Fabrique采取的优化二的方案
    - 我们允许一定误差的存在, 比如,跨度好几页的数据如果出现重复我们可以接受
    - 我们不希望,出现用户滑动列表因为去重出现 **卡顿(算法耗时)**, 或者 **大量占用内存**的情况
    - 所以我们使用 优化二种 **滚动数组** 的方法,避免绝大多数情况的数据重复, 也不会引起**卡顿, 内存消耗大** 等问题.
    - 这也是我们在两者之间找到的一种平衡.
  - 总结 : 
    - Feed流重复问题最好由服务端解决, 因为我们服务端没有方案,只好客户端去处理.
    - 处理时, 要在所用的数据结构和算法, 以及用户体验之间找到一个平衡点.



