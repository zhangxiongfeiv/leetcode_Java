---
title: "原型模式,深拷贝,浅拷贝"
date: 2020-07-14T11:54:29+08:00
draft: true
tags: ["设计模式","iOS"]
---

## 原型模式

> 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
>
> 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

> ## 介绍
>
> **意图：**用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
>
> **主要解决：**在运行期建立和删除原型。
>
> **何时使用：** 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
>
> **如何解决：**利用已有的一个原型对象，快速地生成和原型对象一样的实例。
>
> **关键代码：** 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。
>
> **应用实例：** 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。
>
> **优点：** 1、性能提高。 2、逃避构造函数的约束。
>
> **缺点：** 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。
>
> **使用场景：** 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。
>
> **注意事项：**与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。



## Java 原型模式

- 创建抽象类 Shape, 并实现 **Cloneable**接口, 实现 clone() 方法

  ```java
  public abstract class Shape implements Cloneable{
      private String id;
      protected String type;
      public String getType(){
          return type;
      }
      public String getId() {
          return id;
      }
      public void setId(String id) {
          this.id = id;
      }
      public void setType(String type) {
          this.type = type;
      }
  
      abstract void draw();
  
      public Object clone() {
          Object clone = null;
          try {
              clone = super.clone();
          } catch (CloneNotSupportedException e){
              e.printStackTrace();
          }
          return clone;
      }
  }
  ```

- 创建 上面抽象类的具体实现类

  - Rectangle.java

    ```java
    public class Rectangle extends Shape {
        public Rectangle() {
            type = "Rectangle";
        }
    
        @Override
        void draw() {
            System.out.println("Inside Rectangle::draw() method.");
        }
    }
    ```

  - Squre.java

    ```java
    public class Square extends Shape {
        public Square() {
            type = "Square";
        }
    
        @Override
        void draw() {
            System.out.println("Inside Square::draw() method.");
        }
    }
    ```

  - Ciecle.java

    ```java
    public class Circle extends Shape {
        public Circle() {
            type = "Circle";
        }
    
        @Override
        void draw() {
            System.out.println("Inside Circle::draw() method.");
        }
    }
    ```

- 创建一个类 ShareCache 从数据库获取实体类

  ```java
  public class ShareCache {
      private static Hashtable<String, Shape> shareMap = new Hashtable<String,Shape>();
  
      public static Shape getShape(String shapeId) {
          Shape cachedShape = shareMap.get(shapeId);
          return (Shape) cachedShape.clone();
      }
  
      // 对每种形状都运行数据库查询，并创建该形状
      // shapeMap.put(shapeKey, shape);
      // 例如，我们要添加三种形状
      public static void loadCache(){
          Circle circle = new Circle();
          circle.setId("1");
          shareMap.put(circle.getId(), circle);
  
          Square square = new Square();
          square.setId("2");
          shareMap.put(square.getId(), square);
  
          Rectangle rectangle = new Rectangle();
          rectangle.setId("3");
          shareMap.put(rectangle.getId(), rectangle);
      }
  }
  ```

- 测试代码 

  ```java
      public static void main(String[] args) {
  
          ShareCache.loadCache();
  
          Shape cloneShape1 = (Shape) ShareCache.getShape("1");
          System.out.println("Shape : " + cloneShape1.getType());
  
          Shape cloneShape2 = (Shape) ShareCache.getShape("2");
          System.out.println("Shape : " + cloneShape2.getType());
  
          Shape cloneShape3 = (Shape) ShareCache.getShape("3");
          System.out.println("Shape : " + cloneShape3.getType());
      }
  ```

- 这样，我们就利用 ShareCache类, 原型模式创建了各种 图形实体对象.



## Objc 原型模式

- 在ObjC中，使用原型模式创建自定义对象, 比如 Person类

  - 首先需要遵守 **NSCopying**协议

    ```objc
    @interface Person : NSObject <NSCopying>
    ```

  - 实现 **copyWithZone:** 方法

    ```objc
    - (id)copyWithZone:(nullable NSZone *)zone{
        Person *copyObj = [[[self class] allocWithZone:zone] initWithName:_name gender:_gender];
        return copyObj;
    }
    ```

  - 这时，我们就可以利用 **copy** 来创建 Person 对象了

    ```objc
    int main(int argc, const char * argv[]) {
        @autoreleasepool {
            Person *p1 = [[Person alloc] initWithName:@"Jack" gender:@"male"];
            Person *p2 = p1.copy;
            
            p2.name = @"Rose";
            p2.gender = @"female";
            
            NSLog(@"%@",p1);
            NSLog(@"%@",p2);
        }
        return 0;
    }
    ```

  - 我们覆写了 **description** 方法，最终打印结果如下 : 

    ```objc
    - (NSString *)description{
        return [NSString stringWithFormat:@"%@ is %@, <memory address: %p>", _name, _gender, self];
    }
    ```

    ```
    测试[60329:1050217] Jack is male, <memory address: 0x10059d840>
    测试[60329:1050217] Rose is female, <memory address: 0x10059e010>
    ```

  - 可以看到, 打印出的内存地址不同，我们把这种**copy**称为**深拷贝** (**deep copy**), 也称为**值拷贝**

    - 我们修改 p2 不会对 p1 造成影响， 因为栈中p1 p2两个指针指向堆中两个不同的地址

    ![屏幕快照 2020-07-16 下午5.32.03](/Users/liuxiaoyong/Desktop/屏幕快照 2020-07-16 下午5.32.03.png)

  - 深拷贝的原因，是我们在 copyWithZone 方法中，重新 alloc 了内存空间 , 那假如我们不重新申请内存空间呢?

  - 重写copyWithZone 方法如下 : 

    - 没有重新申请内存空间

    ```objc
    - (id)copyWithZone:(nullable NSZone *)zone{
        Person *copyObj = [self initWithName:_name gender:_gender];
        return copyObj;
    }
    ```

    - main函数中代码不改动，输出结果如下:

    ```
    测试[60355:1053881] Rose is female, <memory address: 0x100612520>
    测试[60355:1053881] Rose is female, <memory address: 0x100612520>
    ```

    - 发现 对 p2的修改，影响了 p1， 并且 p1 和 p2的内存地址是一样的。

  - 这种copy,我们称为 **浅拷贝(Shadow Copy)**, 也叫**指针拷贝**

  - 没有为 p2 申请新的堆空间, 而是将 p2指针执行 p1 指向的地址 。

  - p2的修改，修改了堆空间的值，对p1产生影响





## Objc Foundation类的拷贝

- **NSString, NSArray, NSDictionary**等类型，都实现了 **NSCopying** 协议, 所以这些类，可以通过 copy 创建.
- 本文以 **NSString** 为例, 说明何时为 **深拷贝**， 何时为**浅拷贝**

### NSString的拷贝

- 自定义对象的 **copyWithZone**: 方法，是我们自己实现，我们清楚其是**深拷贝**还是**浅拷贝**
- 但是 **NSString** 的 copy 是深拷贝还是浅拷贝呢 ? 
- 不能看源代码，只能代码验证咯

#### 分四种情况验证

- **不可变**字符串，**copy** 	**-> 浅拷贝**

```objc
        NSString *str1 = @"I am a String";
        NSString *str2 = str1.copy;
        
        NSLog(@"%@,<memory address: %p>", str1, str1);
        NSLog(@"%@,<memory address: %p>", str1, str2);
```

```objc
测试[60501:1063290] I am a String,<memory address: 0x1000020a8>
测试[60501:1063290] I am a String,<memory address: 0x1000020a8>
```

- **可变**字符串, **copy**	-> **深拷贝**

```objc
        NSMutableString *str1 = [NSMutableString stringWithString:@"I am a String"];
        NSString *str2 = str1.copy;
        
        NSLog(@"%@,<memory address: %p>", str1, str1);
        NSLog(@"%@,<memory address: %p>", str1, str2);
```

```objc
测试[60516:1064232] I am a String,<memory address: 0x100608d40>
测试[60516:1064232] I am a String,<memory address: 0x100608e00>
```



- **不可变**字符串, **mutableCopy** -> **深拷贝**

```objc
        NSString *str1 = @"I am a String";
        NSString *str2 = str1.mutableCopy;
        
        NSLog(@"%@,<memory address: %p>", str1, str1);
        NSLog(@"%@,<memory address: %p>", str1, str2);
```

```objc
测试[60527:1065196] I am a String,<memory address: 0x1000020a8>
测试[60527:1065196] I am a String,<memory address: 0x101852a10>
```



- **可变**字符串, **mutableCopy** -> **深拷贝**

```objc
        NSMutableString *str1 = [NSMutableString stringWithString:@"I am a String"];
        NSString *str2 = str1.mutableCopy;
        
        NSLog(@"%@,<memory address: %p>", str1, str1);
        NSLog(@"%@,<memory address: %p>", str1, str2);
```

```objc
测试[60539:1066040] I am a String,<memory address: 0x100554890>
测试[60539:1066040] I am a String,<memory address: 0x100554950>
```



#### 结论

通过以上代码分析，可以得出结论 : 

- **[immutableObj copy]  -> 浅复制**
- **[immutableObj mutableCopy]  -> 深复制**
- **[mutableObj copy]  -> 深复制**
- **[mutableObj copy]  -> 深复制**

以上结论同样适用于 **NSArray**, **NSDictionary** 等数据结构.



参考文献

[菜鸟教程](https://www.runoob.com/design-pattern/prototype-pattern.html)