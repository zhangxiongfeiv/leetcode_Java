#### [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

##### 题解：

###### 思路一：

- 我们使用 HashMap 来存储，子节点的值 -> 父节点。
- dfs二叉树，构建map，保存每个节点对应的父节点
- 根据map，分别获得传入两个节点的祖先节点数组
- 查询这两个祖先节点数组的最近的公共元素
  - 将一个数组转为set
  - 从 0开始遍历第二个数组，找到第一个set中也包含的，就是最终结果。



代码如下：

```java
// 保存 <值 ， 父节点>
    HashMap<Integer, TreeNode> hashMap;

    public void dfs(TreeNode node ,TreeNode parent){
        if (node == null) return;

        hashMap.put(node.val,parent);

        dfs(node.left,node);
        dfs(node.right,node);
    }

    public List getParents(TreeNode node){

        List<TreeNode> plist = new LinkedList<>();

        TreeNode pnode = node;
        while (pnode != null){
            plist.add(pnode);
            pnode = hashMap.get(pnode.val);
        }

        return plist;
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || p == null || q == null) return null;

        hashMap = new HashMap<>();

        // 处理 父节点 字典
        dfs(root,null);

        // p 的所有父节点
        List<TreeNode> plist = getParents(p);

        // q 的所有父节点
        List<TreeNode> qlist = getParents(q);

        HashSet set = new HashSet(plist);

        for (int i = 0; i < qlist.size(); i++) {
            if (set.contains(qlist.get(i)))
                return qlist.get(i);
        }

        return null;
    }
```

时间复杂度 ： O(N)

空间复杂度 ； O(N)

![image-20200511114838745](https://tva1.sinaimg.cn/large/007S8ZIlly1geod8fnorwj30nw066gmd.jpg)



##### 优化：

###### 思路二：



上述解题过程中， 发现我们完全没有用到 **二叉搜索树** 特殊的性质，时间复杂度比较高，由上图可以看出，虽然算法通过，但是执行效率非常差。 接下来，我们尝试优化。

![image-20200511115321556](https://tva1.sinaimg.cn/large/007S8ZIlly1geoddag22vj30bq09odgf.jpg)

- 发现二叉搜索树的最近公共祖先节点，总是在传入两个节点值之间(比如，上图中0, 4的最近公共祖先是 2。 4和7的最近公共祖先是6。)
- 当root.val 比两者都大时，则在左子树中查找
- 当root.val 比两者都小时，则在右子树中查找
- 否则，在两者之间，就是最近公共祖先节点



递归:

代码如下：

```java
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || p == null || q == null) return null;

        if (root.val > q.val && root.val > p.val){

            return lowestCommonAncestor(root.left,p,q);
        }else if (root.val < q.val && root.val < p.val){
            return lowestCommonAncestor(root.right,p,q);
        }

        return root;
    }

```



思路三：

迭代

```java
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || p == null || q == null) return null;

        while (root != null) {
            if (root.val > q.val && root.val > p.val) {
                root = root.left;
            } else if (root.val < q.val && root.val < q.val) {
                root = root.right;
            } else {
                return root;
            }
        }
        return null;
    }
```



#### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

##### 题解：

二叉搜索树中序遍历的结果，是升序数组， 所以先中序遍历数组，第k个元素即为第k个小的元素。

###### 思路一：

迭代 代码如下：

```java
    List<Integer> list = new ArrayList<>();
    List<Integer> dfs (TreeNode root){
        if (root == null) return list;

        dfs(root.left);
        list.add(root.val);
        dfs(root.right);

        return list;
    }

	
    public int kthSmallest(TreeNode root, int k) {

        // 获取数组
        dfs(root);
        return list.get(k);
    }

```



###### 思路二：

递归 代码如下：

```java
List<Integer> dfs1(TreeNode root) {
        List<Integer> list = new ArrayList<>();

        Stack<TreeNode> stack = new Stack<>();
        while (!stack.isEmpty() || root != null) {

            while (root != null) {
                stack.push(root);
                root = root.left;
            }

            root = stack.pop();
            list.add(root.val);
            root = root.right;
        }
        return list;
    }

    public int kthSmallest(TreeNode root, int k) {

        // 获取数组
        List<Integer> list = dfs1(root);

        return list.get(k);
    }
```

上述两种方法中， 时间复杂度都是 O(N) ，遍历了树的所有节点。

空间复杂度也是 O(N), 用到了额外的存储N个元素的数组。



##### 优化：

上述解题，我们看出，我们完全不需要遍历整个二叉树，中序遍历到第K位就能求出结果，完全没必要继续遍历。 所有下边我们优化

###### 思路三：

优化时间复杂度至 O(K), 空间复杂度至 O(1)

迭代 

代码如下：

```java
// 优化遍历次数 且不需要额外数组存储
public int dfs(TreeNode root, int k){
    Stack<TreeNode> stack = new Stack<>();

    int count = 0;
    while (!stack.isEmpty() || root != null){
        while (root != null){
            stack.push(root);
            root = root.left;
        }

        root = stack.pop();
        count ++;
        if (count == k) return root.val;

        root = root.right;
    }

    return -1;
}
```

###### 思路四：

优化时间复杂度至 O(K), 空间复杂度至 O(1)

递归  代码如下：

```java
int count = 0;
    int res;
    public void dfs(TreeNode root,int k){
        if (root == null) return;

        dfs(root.left, k);

        count ++;
        if (k == count) {
            res = root.val;
        }

        dfs(root.right, k);
    }

    public int kthSmallest(TreeNode root, int k) {
        
        dfs(root,k);
        return res;
    }
```



